#!/bin/bash
# Claude Code Hook: Log User Prompts with Auto-Archive
# Trigger: UserPromptSubmit - Runs when user submits a prompt (before Claude processes it)
# Purpose: Save all user prompts with timestamp to PROMPTLOG.md
# Auto-archives file to docs/claude_code/ when > 1000 lines

# Get the JSON input from stdin
INPUT=$(cat)

# Parse JSON to extract the actual prompt text
# Use jq if available, otherwise fallback to grep/sed
if command -v jq &> /dev/null; then
    PROMPT=$(echo "$INPUT" | jq -r '.prompt // empty')
    # If prompt is empty, use raw input as fallback
    if [ -z "$PROMPT" ]; then
        PROMPT="$INPUT"
    fi
else
    # Fallback: Extract prompt field with grep/sed (basic JSON parsing)
    PROMPT=$(echo "$INPUT" | grep -o '"prompt":"[^"]*"' | sed 's/"prompt":"//' | sed 's/"$//')
    # If extraction failed, use raw input
    if [ -z "$PROMPT" ]; then
        PROMPT="$INPUT"
    fi
fi

# Get current timestamp (Vietnamese timezone GMT+7)
TIMESTAMP=$(TZ='Asia/Ho_Chi_Minh' date '+%Y-%m-%d %H:%M:%S')

# File to log prompts
LOG_FILE="PROMPTLOG.md"
ARCHIVE_DIR="docs/claude_code"

# Auto-archive if file exceeds 1000 lines BEFORE writing
if [ -f "$LOG_FILE" ]; then
    LINE_COUNT=$(wc -l < "$LOG_FILE" 2>/dev/null || echo 0)
    if [ "$LINE_COUNT" -gt 1000 ]; then
        # Create archive directory if it doesn't exist
        mkdir -p "$ARCHIVE_DIR"

        # Generate archive filename with timestamp
        ARCHIVE_TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
        ARCHIVE_FILE="$ARCHIVE_DIR/PROMPTLOG_$ARCHIVE_TIMESTAMP.md"

        # Move current file to archive
        mv "$LOG_FILE" "$ARCHIVE_FILE"
        echo "ðŸ“¦ Archived $LOG_FILE -> $ARCHIVE_FILE ($LINE_COUNT lines)" >&2
    fi
fi

# Create log file if it doesn't exist
if [ ! -f "$LOG_FILE" ]; then
    cat > "$LOG_FILE" << 'EOF'
# User Prompts Log
**Auto-generated by Claude Code Hook**

This file contains all user prompts sent to Claude Code, with timestamps.

---

EOF
fi

# Sanitize prompt for markdown
# Keep original formatting without blockquote prefix for better readability and copy-ability
# Only escape backticks to prevent code block issues
SANITIZED_PROMPT=$(echo "$PROMPT" | sed 's/`/\\`/g')

# Format IDE tags with blank lines for better readability
# Add blank line after closing tags
if echo "$SANITIZED_PROMPT" | grep -q '<ide_opened_file>\|<ide_selection>'; then
    SANITIZED_PROMPT=$(echo "$SANITIZED_PROMPT" | sed 's#</ide_opened_file>#&\n#g')
    SANITIZED_PROMPT=$(echo "$SANITIZED_PROMPT" | sed 's#</ide_selection>#&\n#g')
fi

# Validate markdown structure - check for unbalanced code fences
BACKTICK_COUNT=$(echo "$PROMPT" | grep -o '```' | wc -l)
# Check if count is odd (unbalanced)
if [ $((BACKTICK_COUNT % 2)) -ne 0 ]; then
    # Unbalanced code fences - wrap entire prompt in code block
    SANITIZED_PROMPT="\`\`\`text
$PROMPT
\`\`\`"
fi

# Append the prompt to log file
cat >> "$LOG_FILE" << EOF

## ðŸ“ Prompt - $TIMESTAMP

$SANITIZED_PROMPT

---

EOF

# Echo the ORIGINAL input back (required by Claude Code hooks)
# CRITICAL: Must return the full JSON input, not just the prompt text
echo "$INPUT"
