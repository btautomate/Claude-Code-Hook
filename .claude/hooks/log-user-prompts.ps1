# Claude Code Hook: Log User Prompts
# Trigger: UserPromptSubmit - Runs when user submits a prompt (before Claude processes it)
# Purpose: Save all user prompts with timestamp to PROMPTLOG.md

# UTF-8 without BOM encoder (must be defined first)
$utf8NoBom = New-Object System.Text.UTF8Encoding $false

# Force UTF-8 encoding for PowerShell console I/O
$OutputEncoding = [System.Text.Encoding]::UTF8
[Console]::InputEncoding = [System.Text.Encoding]::UTF8
[Console]::OutputEncoding = [System.Text.Encoding]::UTF8

# Read stdin as byte stream and decode with UTF-8
$stdin = [System.Console]::OpenStandardInput()
$reader = New-Object System.IO.StreamReader($stdin, [System.Text.Encoding]::UTF8)
$jsonInput = $reader.ReadToEnd()
$reader.Close()

# Parse JSON to extract the actual prompt text
try {
    $data = $jsonInput | ConvertFrom-Json

    # Extract the prompt field
    if ($data.prompt) {
        $prompt = $data.prompt
    } else {
        # Fallback to raw input if no prompt field
        $prompt = $jsonInput
    }
} catch {
    # If JSON parsing fails, use raw input
    $prompt = $jsonInput
}

# Get current timestamp (Vietnamese timezone GMT+7)
$timestamp = (Get-Date).ToUniversalTime().AddHours(7).ToString("yyyy-MM-dd HH:mm:ss")

# File to log prompts
$logFile = "PROMPTLOG.md"

# Auto-archive if file exceeds 1000 lines BEFORE writing
if (Test-Path $logFile) {
    $lineCount = (Get-Content $logFile -Encoding UTF8).Count
    if ($lineCount -gt 1000) {
        # Create archive directory
        $archiveDir = "docs\claude_code"
        if (-not (Test-Path $archiveDir)) {
            New-Item -ItemType Directory -Path $archiveDir -Force | Out-Null
        }

        # Move file with timestamp
        $archiveTimestamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
        $archivePath = "$archiveDir\PROMPTLOG_$archiveTimestamp.md"
        Move-Item -Path $logFile -Destination $archivePath -Force
        $emojiPackage = [char]::ConvertFromUtf32(0x1F4E6)  # üì¶ emoji
        Write-Host "$emojiPackage Archived $logFile -> $archivePath ($lineCount lines)" -ForegroundColor Cyan
    }
}

# Create log file if it doesn't exist
if (-not (Test-Path $logFile)) {
    $header = "# User Prompts Log`n**Auto-generated by Claude Code Hook**`n`nThis file contains all user prompts sent to Claude Code, with timestamps.`n`n---`n`n"
    [System.IO.File]::WriteAllText((Resolve-Path .).Path + "\$logFile", $header, $utf8NoBom)
}

# Sanitize prompt for markdown
# Keep original formatting without blockquote prefix for better readability and copy-ability
# Only escape backticks to prevent code block issues
$sanitizedPrompt = $prompt -replace '`', '``'

# Format IDE tags with blank lines for better readability
# Extract IDE tags and add spacing
if ($sanitizedPrompt -match '<ide_opened_file>|<ide_selection>') {
    # Add blank line after closing tags for readability
    $sanitizedPrompt = $sanitizedPrompt -replace '(<\/ide_opened_file>)', "`$1`n"
    $sanitizedPrompt = $sanitizedPrompt -replace '(<\/ide_selection>)', "`$1`n"
}

# Validate markdown structure
# Check if prompt contains unbalanced code fences
$backtickCount = ([regex]::Matches($prompt, '```')).Count
if ($backtickCount % 2 -ne 0) {
    # Unbalanced code fences - wrap entire prompt in code block
    $sanitizedPrompt = "``````text`n$prompt`n``````"
}

# Append the prompt to log file
# Note: Using [char]0x1F4DD for üìù emoji to avoid encoding issues
$emojiPrompt = [char]::ConvertFromUtf32(0x1F4DD)  # üìù emoji

# Format entry with proper markdown structure
$entry = "`n## $emojiPrompt Prompt - $timestamp`n`n$sanitizedPrompt`n`n---`n`n"

[System.IO.File]::AppendAllText((Resolve-Path .).Path + "\$logFile", $entry, $utf8NoBom)

# Echo the ORIGINAL input back (required by Claude Code hooks)
# CRITICAL: Must return the full JSON input, not just the prompt text
# Use Write-Host with UTF-8 to preserve encoding
$stdout = [System.Console]::OpenStandardOutput()
$writer = New-Object System.IO.StreamWriter($stdout, [System.Text.Encoding]::UTF8)
$writer.WriteLine($jsonInput)
$writer.Flush()
$writer.Close()
