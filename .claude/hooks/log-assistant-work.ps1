# Claude Code Hook: Log Work Summary
# Trigger: Stop - Runs when Claude completes a response
# Purpose: Save summary of work done by Claude to WORKLOG.md

# Get the response content from stdin (JSON format)
# NOTE: PowerShell's $input is an automatic variable that contains pipeline input
$jsonInput = @($input) -join "`n"

# UTF-8 without BOM encoder
$utf8NoBom = New-Object System.Text.UTF8Encoding $false

# Parse JSON to extract session info and transcript path
try {
    $data = $jsonInput | ConvertFrom-Json

    # Extract assistant messages from transcript file
    $assistantMessages = @()

    # Claude Code provides transcript_path in the Stop hook JSON
    if ($data.transcript_path) {
        # Read JSONL transcript file (each line is a JSON object)
        if (Test-Path $data.transcript_path) {
            # Use .NET API for proper UTF-8 handling without BOM issues
            $transcriptLines = [System.IO.File]::ReadAllLines($data.transcript_path, [System.Text.Encoding]::UTF8)

            # Process each line (JSONL format)
            foreach ($line in $transcriptLines) {
                if (-not [string]::IsNullOrWhiteSpace($line)) {
                    try {
                        $msg = $line | ConvertFrom-Json

                        # Extract assistant messages
                        # Claude Code transcript format: {"message": {"role": "assistant", "content": [...]}}
                        $messageObj = $null
                        if ($msg.message) {
                            $messageObj = $msg.message
                        } elseif ($msg.role) {
                            $messageObj = $msg
                        }

                        if ($messageObj -and $messageObj.role -eq "assistant" -and $messageObj.content) {
                            foreach ($content in $messageObj.content) {
                                if ($content.type -eq "text" -and $content.text) {
                                    $assistantMessages += $content.text
                                }
                            }
                        }
                    } catch {
                        # Skip invalid JSON lines
                        continue
                    }
                }
            }
        }
    }

    # Combine all assistant messages
    if ($assistantMessages.Count -gt 0) {
        # Get ONLY the last assistant message (most recent response)
        $workSummary = $assistantMessages[-1]
    } else {
        $workSummary = "[No assistant messages found in transcript]"
    }

} catch {
    # If parsing fails, create error message with exception details
    $workSummary = "[Error reading transcript: $($_.Exception.Message)]"
}

# Get current timestamp (Vietnamese timezone GMT+7)
$timestamp = (Get-Date).ToUniversalTime().AddHours(7).ToString("yyyy-MM-dd HH:mm:ss")

# File to log work summaries
$logFile = "WORKLOG.md"

# Auto-archive if file exceeds 1000 lines
if (Test-Path $logFile) {
    $lineCount = (Get-Content $logFile -Encoding UTF8).Count
    if ($lineCount -gt 1000) {
        # Create archive directory
        $archiveDir = "docs\claude_code"
        if (-not (Test-Path $archiveDir)) {
            New-Item -ItemType Directory -Path $archiveDir -Force | Out-Null
        }

        # Move file with timestamp
        $archiveTimestamp = (Get-Date).ToString("yyyyMMdd_HHmmss")
        $archivePath = "$archiveDir\WORKLOG_$archiveTimestamp.md"
        Move-Item -Path $logFile -Destination $archivePath -Force
        $emojiPackage = [char]::ConvertFromUtf32(0x1F4E6)  # ðŸ“¦ emoji
        Write-Host "$emojiPackage Archived $logFile -> $archivePath ($lineCount lines)" -ForegroundColor Cyan
    }
}

# Create log file if it doesn't exist
if (-not (Test-Path $logFile)) {
    $header = "# Claude Code Work Log`n**Auto-generated by Claude Code Hook**`n`nThis file contains summaries of work completed by Claude Code, with timestamps.`n`n---`n`n"
    [System.IO.File]::WriteAllText((Resolve-Path .).Path + "\$logFile", $header, $utf8NoBom)
}

# Append the work summary to log file
# Note: Using [char]0x1F916 for ðŸ¤– emoji to avoid encoding issues
$emojiRobot = [char]::ConvertFromUtf32(0x1F916)  # ðŸ¤– emoji

# Don't wrap in code fence to avoid nested markdown issues
# Just use plain text with proper spacing
$entry = "`n## $emojiRobot Work Completed - $timestamp`n`n$workSummary`n`n---`n`n"

[System.IO.File]::AppendAllText((Resolve-Path .).Path + "\$logFile", $entry, $utf8NoBom)

# Echo the input back (required by Claude Code hooks)
Write-Output $jsonInput